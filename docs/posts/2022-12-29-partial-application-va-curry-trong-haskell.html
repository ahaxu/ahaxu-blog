<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.9.1/font/bootstrap-icons.css">
        <title>AhaXu Blog - Giới thiệu về lambda calculus, partial application và curry trong haskell</title>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-1PHNTX4TPM"></script>
        <script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());

              gtag('config', 'G-1PHNTX4TPM');
        </script>
    </head>
    <body class"container-fluid">
        <div id="header">
            <div id="logo">
                <a href="../">AhaXu Blog</a>
            </div>
            <div id="navigation">
              <a href="../"><i class="bi bi-house-heart-fill"></i> </a>
                <a href="../about.html"><i class="bi bi-info-circle-fill"></i> </a>
                <a href="../archive.html"><i class="bi bi-archive-fill"></i> </a>
            </div>
        </div>

        <div id="content">
            
                <h2>Giới thiệu về lambda calculus, partial application và curry trong haskell</h2>
                <div class="info">
    Posted on December 29, 2022
    
        by lk
    
</div>

<h2 id="outline">Outline</h2>
<ul>
<li>Giới thiệu về <strong>Lambda calculus</strong></li>
<li>Function <code>(-&gt;)</code>, partial application và curry trong haskell</li>
<li>Function application (<code>($)</code>)</li>
</ul>
<h2 id="giới-thiệu-về-lambda-caluculus">Giới thiệu về lambda caluculus</h2>
<ul>
<li>Lambda structure</li>
</ul>
<pre><code>λ x . x
^─┬─^
  └────── the extent of the head of the lambda.
λ x . x
  ^────── the single parameter of the function. This
          binds any variables with the same name
          in the body of the function.
λ x . x
      ^── body, the expression the lambda returns
          when applied. This is a bound variable.</code></pre>
<ul>
<li>Beta reduction</li>
</ul>
<p>When we apply a function to an argument, we substitute the input expression for all instances of bound variables within the body of the abstraction. You also eliminate the head of the abstraction, since its only purpose was to bind a variable. This process is called beta reduction.
Let’s use the function we had above:
𝜆𝑥.𝑥
We’ll do our first beta reduction using a number.2 We apply the function above to 2, substitute 2 for each bound variable in the body of the function, and eliminate the head:
(𝜆𝑥.𝑥) 2 2</p>
<ul>
<li>Nested lambda</li>
</ul>
<pre><code>𝜆𝑥𝑦.𝑥𝑦</code></pre>
<p>tương đương với</p>
<pre><code>𝜆𝑥.(𝜆𝑦.𝑥𝑦)</code></pre>
<h2 id="function---and-partial-application">Function (-&gt;) and partial application</h2>
<pre><code>Prelude&gt; :info (-&gt;)
type (-&gt;) :: * -&gt; * -&gt; *
data (-&gt;) a b
        -- Defined in ‘GHC.Prim’
infixr -1 -&gt;
instance Applicative ((-&gt;) r) -- Defined in ‘GHC.Base’
instance Functor ((-&gt;) r) -- Defined in ‘GHC.Base’
instance Monad ((-&gt;) r) -- Defined in ‘GHC.Base’
instance Monoid b =&gt; Monoid (a -&gt; b) -- Defined in ‘GHC.Base’
instance Semigroup b =&gt; Semigroup (a -&gt; b) -- Defined in ‘GHC.Base’</code></pre>
<p>The way the type constructor for functions, (-&gt;), is defined makes currying the default in Haskell. This is because it is an infix operator and right associative. Because it associates to the right, types get parenthesized like so:</p>
<pre><code>a -&gt; a -&gt; a
-- gets paren'd into
a -&gt; (a -&gt; a)
-- and
(a -&gt; b) -&gt; [a] -&gt; [b]
-- gets paren'd into
(a -&gt; b) -&gt; ([a] -&gt; [b])</code></pre>
<p>When one considers that (-&gt;) is a type constructor and associates to the right, this becomes more clear.</p>
<pre><code>addStuff :: Integer -&gt; Integer -&gt; Integer -- but with explicit parenthesization
addStuff :: Integer -&gt; (Integer -&gt; Integer)</code></pre>
<p>The way you can read the explicitly parenthesized type for addStuff is, “I take an Integer argument and return a function that takes an In- teger and returns an Integer.” You saw this in action when we partially applied the addStuff function above.</p>
<h2 id="function-application">Function application ($)</h2>
<pre><code>Prelude&gt; :info ($)
($) :: (a -&gt; b) -&gt; a -&gt; b       -- Defined in ‘GHC.Base’
infixr 0 $</code></pre>
<h2 id="tài-liệu-tham-khảo">Tài liệu tham khảo</h2>
<ul>
<li><a href="https://www.goodreads.com/en/book/show/25587599-haskell-programming-from-first-principles">Haskell Programming from First Principles</a></li>
</ul>

            
        </div>
        <div id="footer">
            AhaXuBlog@2022 - generated by Hakyll
        </div>
    </body>
</html>
